#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import json
import re
from datetime import datetime
from collections import defaultdict

import asyncio
from asyncio.subprocess import PIPE
from asyncio import Queue, sleep, create_subprocess_exec as aiopopen

class Widget:
    def __init__(self):
        self.text = ''
        self.color = ''

    def to_dict(self):
        d = {'full_text': self.text}

        if self.color:
            d['color'] = self.color

        return d


class Panel:
    def __init__(self):
        self.loop = asyncio.get_event_loop()
        self.q = Queue()
        self._listeners = []

    async def start(self):
        """
        Starts the workers and runs them in parallel.
        """
        consumer = self.renderer()
        producers = [
            self.volume(),
            self.mpd(),
            self.calendar(),
            self.clock()
        ]

        await asyncio.wait([consumer, *producers])

    async def renderer(self):
        """
        Receives the data from the workers queue and renders it to i3bar
        """
        state = defaultdict(Widget)

        self.write({'version': 1})

        # Begin infinite array.
        print('[[],')

        while True:
            new_state = await self.q.get()
            state.update(new_state)

            widgets = ['volume', 'music', 'date', 'time']
            widgets = [state[w].to_dict() for w in widgets]

            self.write(widgets, end=',', flush=True)

    async def calendar(self):
        """
        Calculates the current date, and waits until tomorrow to do so again.
        """
        widget = Widget()

        while True:
            widget.text = time.strftime('%a %d %b')
            await self.q.put({'date': widget})

            now = datetime.now()
            seconds_elapsed = (now.hour * 3600) - (now.minute * 60) - now.second
            seconds_until_tomorrow = 86400 - seconds_elapsed
            await sleep(seconds_until_tomorrow)

    async def clock(self):
        """
        Computes the current time every second.
        """
        widget = Widget()

        while True:
            widget.text = time.strftime('%H:%M:%S')
            await self.q.put({'time': widget})

            await sleep(1)

    async def mpd(self):
        """
        Fetches the current song from `mpc` and waits until `mpc idleloop`
        reports a `player` action (song switched, paused, unpaused or stopped)
        """
        widget = Widget()
        q = Queue()

        asyncio.ensure_future(self._mpd_listener(q))

        while True:
            mpc = await q.get()

            widget.text = mpc.split('\n')[0]

            if '[playing]' in mpc:
                widget.color = '#ffffff'
            elif '[paused]' in mpc:
                widget.color = '#e7c547'
            else:
                widget.text = 'NOTHING PLAYING'
                widget.color = '#d54e53'

            await self.q.put({'music': widget})

    async def volume(self):
        widget = Widget()
        q = Queue()

        asyncio.ensure_future(self._volume_listener(q))

        while True:
            pactl = await q.get()

            volume = re.search(r'([0-9]+)%', pactl).group(1)
            volume = int(volume)

            muted = 'Mute: yes' in pactl

            # Prevent fuck ups.
            if volume > 100:
                await aiopopen('pactl', 'set-sink-volume', '0', '100%')

            if muted:
                widget.color = '#d54e53'

            widget.text = "VOL: {}".format(mkbar(volume))

            await self.q.put({'volume': widget})

    async def _mpd_listener(self, q):
        idleloop = await aiopopen('mpc', 'idleloop', 'player', stdout=PIPE)
        self._listeners.append(idleloop)

        while True:
            proc = await aiopopen('mpc', stdout=PIPE)
            mpc = await proc.stdout.read()
            mpc = mpc.decode()

            await q.put(mpc)

            await idleloop.stdout.readline()

    async def _volume_listener(self, q):
        sub = await aiopopen('pactl', 'subscribe', 'change', stdout=PIPE)
        self._listeners.append(sub)

        while True:
            proc = await aiopopen('pactl', 'list', 'sinks', stdout=PIPE)
            pactl = await proc.stdout.read()

            await q.put(pactl.decode())

            await sub.stdout.readline()

    @staticmethod
    def write(*args, **kwargs):
        print(json.dumps(*args), **kwargs)

    def run(self):
        """
        Initialize the event loop and clean up when exitting.
        """
        try:
            self.loop.run_until_complete(self.start())
        except KeyboardInterrupt:
            pending = asyncio.Task.all_tasks()
            gathered = asyncio.gather(*pending)

            try:
                gathered.cancel()
                self.loop.run_until_complete(gathered)

                for proc in self._listeners:
                    proc.kill()

                gathered.exception()
            except:
                pass
            finally:
                self.loop.stop()
        finally:
            self.loop.close()

def mkbar(value):
    if value > 100:
        value = 100
    elif value < 0:
        value = 0

    value = round(value / 100 * 16)
    remainder = 16 - value

    bar = []

    if value > 0:
        bar.append('|' * value)
    if remainder > 0:
        bar.append('-' * remainder)

    return ''.join(bar)

if __name__ == '__main__':
    panel = Panel()
    panel.run()
