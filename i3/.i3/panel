#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import json
import re
from datetime import datetime
from collections import defaultdict

import asyncio
from asyncio.subprocess import PIPE
from asyncio import Queue, sleep, create_subprocess_exec as aiopopen

class Widget:
    def __init__(self):
        self.text = ''
        self.color = ''

    def __repr__(self):
        d = {'full_text': self.text}

        if self.color:
            d['color'] = self.color

        return json.dumps(d)


class Panel:
    def __init__(self):
        self.loop = asyncio.get_event_loop()
        self.listeners = []
        self.q = Queue()

    async def start(self):
        """
        Starts the workers and runs them in parallel.
        """
        consumer = self.renderer()
        producers = [
            # self.volume(),
            self.mpd(),
            self.calendar(),
            self.clock()
        ]

        await asyncio.wait(producers + [consumer])

    async def renderer(self):
        """
        Receives the data from the workers queue and renders it to i3bar
        """
        state = defaultdict(lambda: Widget())

        print(json.dumps({'version': 1}), end='\n[\n')

        while True:
            new_state = await self.q.get()
            state.update(new_state)

            widgets = [state['music'], state['date'], state['time']]

            print(widgets, end=',\n', flush=True)

    async def calendar(self):
        """
        Calculates the current date, and waits until tomorrow to do so again.
        """
        widget = Widget()

        while True:
            widget.text = time.strftime('%a %d %b')
            await self.q.put({'date': widget})

            now = datetime.now()
            seconds_elapsed = (now.hour * 3600) - (now.minute * 60) - now.second
            seconds_until_tomorrow = 86400 - seconds_elapsed
            await sleep(seconds_until_tomorrow)

    async def clock(self):
        """
        Computes the current time every second.
        """
        widget = Widget()

        while True:
            widget.text = time.strftime('%H:%M:%S')
            await self.q.put({'time': widget})

            await sleep(1)

    async def mpd(self):
        """
        Fetches the current song from `mpc` and waits until `mpc idleloop`
        reports a `player` action (song switched, paused, unpaused or stopped)
        """
        widget = Widget()
        idleloop = await aiopopen('mpc', 'idleloop', 'player', stdout=PIPE)
        self.listeners.append(idleloop)

        while True:
            proc = await aiopopen('mpc', stdout=PIPE)
            mpc = (await proc.stdout.read()).decode()

            widget.text = mpc.split('\n')[0]

            if '[playing]' in mpc:
                widget.color = '#ffffff'
            elif '[paused]' in mpc:
                widget.color = '#e7c547'
            else:
                widget.text = 'NOTHING PLAYING'
                widget.color = '#d54e53'

            await self.q.put({'music': widget})

            # Wait until next event.
            await idleloop.stdout.readline()

    async def volume(self):
        widget = Widget()
        sub = await aiopopen('pactl', 'subscribe', 'change', stdout=PIPE)
        self.listeners.append(sub)

        while True:
            proc = await aiopopen('pactl', 'list', 'sinks')
            pactl = (await proc.stdout.read()).decode()

            volume = re.search('([0-9])+%', pactl).group(1)
            volume = int(volume)

            muted = 'Mute: yes' in pactl

            # Prevent fuck ups.
            if volume > 100:
                await aiopopen('pactl', 'set-sink-volume', '0', '100%')

            if muted:
                widget.color = '#d54e53'

            widget.text = mkbar(volume)

    def run(self):
        """
        Initialize the event loop and clean up when exitting.
        """
        try:
            self.loop.run_until_complete(self.start())
        except KeyboardInterrupt:
            pending = asyncio.Task.all_tasks()
            gathered = asyncio.gather(*pending)

            try:
                gathered.cancel()
                self.loop.run_until_complete(gathered)

                for proc in self.listeners:
                    proc.kill()

                gathered.exception()
            except:
                pass
            finally:
                self.loop.stop()
        finally:
            self.loop.close()

def mkbar(value):
    if value > 100:
        value = 100
    elif value < 0:
        value = 0

    value = round(value / 100 * 16)
    remainder = 16 - value

    bar = []

    if value > 0:
        bar.append('|' * value)
    if remainder > 0:
        bar.append('-' * remainder)

    return ''.join(bar)

if __name__ == '__main__':
    panel = Panel()
    panel.run()
