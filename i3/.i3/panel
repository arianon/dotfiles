#!/usr/bin/python3.6
# -*- coding: utf-8 -*-

import time
import json
import re
from datetime import datetime
from collections import defaultdict

import asyncio
from asyncio.subprocess import PIPE
from asyncio import Queue, sleep, create_subprocess_exec as aiopopen


class Widget:
    def __init__(self):
        self.text = ''
        self.color = ''

    def to_dict(self):
        d = {'full_text': self.text}

        if self.color:
            d['color'] = self.color

        return d


class Panel:
    def __init__(self):
        self.loop = asyncio.get_event_loop()
        self._listeners = []

    async def start(self):
        """
        Receives the data from the workers queue and renders it to i3bar
        """

        self.write({'version': 1})

        # Begin infinite array.
        print('[[],')

        async for widgets in self.consume():
            widgets = [widgets[w] for w in 'volume music calendar clock'.split()]

            self.write(widgets, end=',\n', flush=True)


    async def calendar(self):
        """
        Calculates the current date, and waits until tomorrow to do so again.
        """
        widget = Widget()

        while True:
            widget.text = time.strftime('%a %d %b')

            yield widget

            now = datetime.now()
            seconds_elapsed = (now.hour * 3600) - (now.minute * 60) - now.second
            seconds_until_tomorrow = 86400 - seconds_elapsed
            await sleep(seconds_until_tomorrow)

    async def clock(self):
        """
        Computes the current time every second.
        """
        widget = Widget()

        while True:
            widget.text = time.strftime('%H:%M:%S')

            yield widget

            await sleep(1)

    async def music(self):
        """
        Fetches the current song from `mpc` and waits until `mpc idleloop`
        reports a `player` action (song switched, paused, unpaused or stopped)
        """
        widget = Widget()

        async for mpc in self._mpd_listener():
            widget.text = mpc.split('\n')[0]

            if '[playing]' in mpc:
                widget.color = '#ffffff'
            elif '[paused]' in mpc:
                widget.color = '#e7c547'
            else:
                widget.text = ''
                # widget.color = '#d54e53'

            yield widget

    async def volume(self):
        """
        Fetches the volume from `pactl` and waits until `pactl subscribe`
        reports actions on the "sink" (volume stuff)
        """
        widget = Widget()

        async for pactl in self._pulseaudio_listener():
            volume = re.search(r'([0-9]+)%', pactl).group(1)
            volume = int(volume)

            muted = 'Mute: yes' in pactl

            # Prevent fuck ups.
            if volume > 100:
                await aiopopen('pactl', 'set-sink-volume', '0', '100%')

            if muted:
                widget.color = '#d54e53'

            widget.text = "VOL: {}%".format(volume)

            yield widget

    async def _mpd_listener(self):
        idleloop = await aiopopen('mpc', 'idleloop', 'player', stdout=PIPE)
        self._listeners.append(idleloop)

        while True:
            proc = await aiopopen('mpc', stdout=PIPE)
            mpc = await proc.stdout.read()
            mpc = mpc.decode()

            yield mpc

            await idleloop.stdout.readline()

    async def _pulseaudio_listener(self):
        sub = await aiopopen('pactl', 'subscribe', stdout=PIPE)
        self._listeners.append(sub)

        async def pactl():
            proc = await aiopopen('pactl', 'list', 'sinks', stdout=PIPE)
            pactl = await proc.stdout.read()
            return pactl.decode()

        yield await pactl()

        while True:
            message = await sub.stdout.readline()

            # Only care about messages about the sink.
            if b'sink' in message:
                yield await pactl()

    async def consume(self):
        """
        Starts the workers, running them in parallel.

        This is where the black magic happens.
        """
        state = defaultdict(dict)
        queue = Queue()
        producers = [self.volume, self.music, self.calendar, self.clock]

        async def consume_agen(agen):
            async for widget in agen():
                await queue.put({
                    agen.__name__: widget.to_dict()
                })

        for agen in producers:
            self.loop.create_task(consume_agen(agen))

        while True:
            state.update(await queue.get())

            yield state


    @staticmethod
    def write(*args, **kwargs):
        print(json.dumps(*args), **kwargs)

    def run(self):
        """
        Initialize the event loop and clean up when exitting.
        """
        try:
            self.loop.run_until_complete(self.start())
        except KeyboardInterrupt:
            pending = asyncio.Task.all_tasks()
            gathered = asyncio.gather(*pending)

            try:
                gathered.cancel()
                self.loop.run_until_complete(gathered)

                for proc in self._listeners:
                    proc.kill()

                gathered.exception()
            except:
                pass
            finally:
                self.loop.stop()
        finally:
            self.loop.close()


def mkbar(value):
    value = max(min(value, 100), 0)
    value = round(value / 100 * 16)
    remainder = 16 - value

    bar = []

    if value > 0:
        bar.append('|' * value)
    if remainder > 0:
        bar.append('-' * remainder)

    return ''.join(bar)


if __name__ == '__main__':
    panel = Panel()
    panel.run()
